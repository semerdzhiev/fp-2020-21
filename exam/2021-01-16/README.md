*Важно: Решете задачите на Haskell. За всяка от функциите напишете подходящи unit test-ове. За тестовете трябва да се използва HUnit. Решението попълнете в предварително подготвените шаблонни файлове (в GitHub хранилището на курса те са налични в папката `templates`)*

# Задача 1

Двоично дърво в Haskell ще представяме чрез следния тип, който ви е познат от домашните:

```haskell
data Tree a = EmptyTree | Node {
                            value :: a,
                            left  :: Tree a,
                            right :: Tree a
                          } deriving (Show,Read)
```

Например дървото

```
    a
   / \
  b   c
 / \   \
d   e   f
 \
  g
```

можем да запишем в променлива по следния начин:

```haskell
sampleTree = Node 'a' (Node 'b' (Node 'd' EmptyTree
                                          (Node 'g' EmptyTree EmptyTree))
                                (Node 'e' EmptyTree EmptyTree))
                      (Node 'c' EmptyTree
                                (Node 'f' EmptyTree EmptyTree))
```


## Вариант А

Нека е дадено двоично дърво от символи от тип `Char`. Напишете функция, която връща списък от всички думи, които могат да се образуват по път от корена, до някое от листата на дървото. Ако дървото е празно, да се връща празният списък.

Например за дървото от примера списъкът от възможни думи е:

```haskell
["abdg", "abe", "acf"]
```
Функцията трябва да има следния тип:

```haskell
treeWords :: Tree Char -> [String]
```



## Вариант Б

Нека е даден символен низ `str` и дърво с елементи от тип `Char`. Напишете функция, която проверява дали `str` се съдържа в някой път от корена на дървото към негово листо. Символите трябва да се срещат точно в реда им от `str`. Не е задължително да се срещат непосредствено един след друг.

Например в дървото от примера считаме, че

* се съдържат например низовете `""`, `"a"`, `"b"`, `"abdg"`, `"bd"`, `"ae"`.
* НЕ СЕ съдържат `"ea"`, `"zx"`, `"abb"`

Функцията трябва да има следния тип:

```haskell
treeContains:: Tree Char -> String -> Bool
```


## Вариант В

Нека е дадено двоично дърво от символи от тип `Char`. _"Ниво N"_ на дървото ще наричаме множество, което дефинираме по следния начин:

* ако дървото е празно, то няма нива;
* коренът на дървото е единственият елемент в ниво 0;
* в ниво N влизат всички елементи, които са на разстояние точно N от корена на дървото.

Например за дървото от примера нивата са:

* ниво 0: { a }
* ниво 1: { b, c }
* ниво 2: { d, e, f }
* ниво 3: { g }

Напишете функция, която връща списък от всички нива в дървото. Нивата да се представят като думи -- символни низове образувани от елементите в нивото, подредени от най-левия към най-десния. Ако дървото е празно, да се връща празният списък.

Например за даденото по-горе дърво, функцията трябва да върне

```haskell
["a", "bc", "def", "g"]
```

Функцията трябва да има следния тип:

```haskell
treeLevels :: Tree Char -> [String]
```

---


# Задача 2.

**В решението на тази задача не може да се използва рекурсия. Рекурсивни решения ще бъдат оценявани с нула точки.**

**Упътване:** в задачата използвайте _list comprehension_ и някоя/и от дадените по-долу библиотечни функции на Haskell. За някои от тях (например `nub` е такава) може да се наложи да импортирате модула `Data.List`.

* `minimum` (намира минимален елемент на списък)
* `maximum` (намира максимален елемент на списък)
* `nub` (премахва повторения от списък)
* `intersect` (намира сечение на два списъка)
* `\\` (оператор, който намира разлика на два списъка)
* и т.н.

Реализирайте функцията

## Вариант А

```haskell
mapsTo :: Integral t => (t -> t) -> t -> t -> (t,t)
mapsTo f a b
```

Тя получава границите на целочислен интервал $[a,b]$ и функция от вида

```haskell
f :: Integral t => t -> t
```

`mapsTo` трябва да върне най-малкия целочислен интервал, който обхваща образа на $[a,b]$ проектиран от `f`. Казано по-точно, трябва да се върне най-малкият интервал $[c,d]$, такъв, че:

<img src="https://render.githubusercontent.com/render/math?math=\forall(x \in [a,b])(f(x) \in [c,d])">

Интервалът да се върне като наредена двойка от неговите граници. Например интервалът $[1,5]$ трябва да се върне като `(1,5)`.

## Вариант Б

```haskell
isInjective :: Integral t => (t -> t) -> t -> t -> Bool
isInjective f a b
```

Тя получава границите на целочислен интервал $[a,b]$ и функция от вида

```haskell
f :: Integral t => t -> t
```

`isInjective` връща истина тогава и само тогава, когато рестрикцията на `f` върху интервала $[a,b]$ е инекция. Тоест, за всички числа в интервала, `f` връща различни стойности или формално казано:

<img src="https://render.githubusercontent.com/render/math?math=\forall(x,y \in [a,b])(x \neq y \implies f(x) \neq f(y))">


## Вариант В

```haskell
isSurjective :: Integral t => (t -> t) -> t -> t -> t -> t -> Bool
isSurjective f a b c d
```

Тя получава целочислени интервали $[a,b]$ и $[c,d]$ и функция от вида

```haskell
f :: Integral t => t -> t
```

`isSurjective` връща истина тогава и само тогава, когато рестрикцията на `f` върху $[a,b]$ е сюрекция. Тоест, всеки елемент на интервала $[c,d]$ е образ на поне един елемент от $[a,b]$ или формално:

<img src="https://render.githubusercontent.com/render/math?math=\forall(y \in [c,d])\exists(x \in [a,b])(y = f(x))">
