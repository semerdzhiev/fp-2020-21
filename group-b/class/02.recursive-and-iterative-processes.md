# Втора седмица

## Какво правихме?

1. Говорихме си за разликите между итеративни и рекурсивни процеси
2. Видяхме примери за гореспоменатите разлики
3. Видяхме какво са вътрешни дефиниции и какви проблеми решават
4. Пресмятахме разни неща с по-малко стъпки

## [Допълнително четиво](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2)


## 1,2. Разлики между итеративни и рекурсивни процеси

Започваме с пример за рекурсивен процес:
```Scheme
(define (factorial n)
  (if (= n 0)
    1
    (* n (factorial (- n 1)))
  )
)
```

Нека видим какво се случва при `(factorial 6)`:
```Scheme
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 (* 1 (factorial 0)))))))
(* 6 (* 5 (* 4 (* 3 (* 2 (* 1 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
profit.
```

Вижда се, че изпълнението на умноженията започва да се случва едва след като се стигне дъното на рекурсията. Така написана, програмата заема допълнителна памет за всяко извикване на `factorial`. Процес, който има вид, подобен на горния, се нарича рекурсивен.

Друг начин за пресмятане на същата математическа функция:
```Scheme
(define (fact-iter n product)
  (if (= n 0)
    product
    (fact-iter (- n 1) (* product n))
  )
)
```

Какво се случва при извикването `(fact-iter 6 1)`
```Scheme
(fact-iter 6 1)
(fact-iter 5 6)
(fact-iter 4 30)
(fact-iter 3 120)
(fact-iter 2 360)
(fact-iter 1 720)
(fact-iter 0 720)
720
profit.
```

Тук пазим "текущия" резултат на процедурата като нейн аргумент. Когато стигнем базовия случай, за n = 0, връщаме натрупаната стойност във втория аргумент.

Разликата между този начин на пресмятане на функцията е, че процесът не "расте" с времето (както се случва при рекурсивния вариант) - нямаме отложени пресмятания. Процес, който се определя от краен брой променливи (в нашия случай n и product) се нарича итеративен.  
В типичните императивни езици има езикови конструкции, които се грижат за итерация - for, while, do while, etc. За тях е нормално да има една (или повече) променлива, да кажем брояч, която определя състоянието на процеса.



В час си показахме как би се случило пресмятането на n-тото число на Фибоначи чрез итеративна процедура:

```Scheme
(define (fibonacci-iter a b count)
  (if (= count 0)
    b
    (fibonacci-iter (+ a b) a (- count 1))
  )
)
(fibonacci-iter n 1 0)
```

Тази процедура разчита на трансформацията
```Scheme
a <- a + b
b <- a
```

## 3. Вътрешни дефиниции

Можем да допълним итеративния вариант на процедурата по следния начин:
```Scheme
(define (factotial n)
  (define (fact-iter n product)
    (if (= n 0)
      1
      (fact-iter (- n 1) (* product n))
    )
  )
  (fact-iter n 1)
)
```
Тук дефинираме `fact-iter` в тялото на `factorial`, а след това връщаме `(fact-iter n 1)` като резултат.  
Q: Защо подобни дефиниции са валидни?  
A: Защото в процедура може да има неограничен брой последователни изрази, но само последния такъв се връща като резултат.

Вътрешната дефиниция на `fact-iter` е видима единствено в тялото на `factorial`. По този начин "скриваме" `fact-iter`, тъй като от нея се нуждаем единствено за пресмятането на 'fact'.  
Името `n` в тялото на `fact-iter` няма нищо общо с това във `factorial` - вътрешната функция дефинира своя област на видимост.

Ако искаме да постигнем същото с `fibonacci-iter`:
```Scheme
(define (fibonacci n)
  (define (fibonacci-iter a b count)
    (if (= count 0)
      b
      (fibonacci-iter (+ a b) a (- count 1))
    )
  )
  (fibonacci-iter n 1 0)
)
```

[Хубав пример](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.7) за вътрешни дефиниции и ползите от тях.

Препоръчвам [тази задача](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_thm_1.19), в която се иска да намалим броя пресмятания за намиране на n-тото число на Фибоначи.
