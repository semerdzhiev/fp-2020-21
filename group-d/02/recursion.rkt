#lang racket

; Throwback:
; - Нямаме цикли, само рекурсия
; - Константи
; - Всичко е стойност (в частност функциите)
; - кода на scheme е под формата на списъци
; - Функции (извикване, дефиниране)
; - quote и символи
; - define, if, cond
; - Малко рекурсия

; ; Не упражнихме всичко, но ето някои вградени функции:
; *, +, -, /
; Заб: горните работят върху произволен брой аргументи
; remainder, quotient, max, min, gcd, lcm
; floor, ceiling, round
; exp, expt, sqrt, log, sin, cos, tan, asin, acos, atan
; <, >, =, <=, >=
; zero?, negative?, positive?, even?, odd?
; boolean?, number?, char?, string?, symbol?, procedure?
; equal?

; Гледайте документацията за справка.


; Миналия път показахме как можем да дефинираме функции
; с define.
(define (plus2 n) (+ n 2))

; Можем да правим вложени дефиниции
(define (square-plus2 n)
  (define (square x) (expt x 2))
  (+ (square n) 2))

(square-plus2 3) ; 11


; Нека разгледаме n!
(define (factorial n)
  (if (= n 0)
    1
    (* n (factorial (- n 1)))))

; ако бележим factorial с f, изчислителния процес на 5!
; изглежда така:
;(f 5)
;(* 5 (f 4))
;(* 5 (* 4 (f 3)))
;(* 5 (* 4 (* 3 (f 2))))
;(* 5 (* 4 (* 3 (* 2 (f 1)))))
;(* 5 (* 4 (* 3 (* 2 (* 1 (f 0))))))
;(* 5 (* 4 (* 3 (* 2 (* 1 1)))))
;(* 5 (* 4 (* 3 (* 2 1))))
;(* 5 (* 4 (* 3 2)))
;(* 5 (* 4 6))
;(* 5 24)
;120

; памет: O(n)
; време: О(n)

; Това е същински рекурсивен процес заради отложените операции.

; Използвайки вложена дефиниция:
(define (factorial-iter n)
  (define (iter product counter)
    ; тук напрактика ползваме помощни аргументи,
    ; до които крайният требител няма достъп
    (if (> counter n)
      product
      (iter
        (* counter product)
        (+ counter 1))))
  (iter 1 1))

; Вече изчислителния процес изглежда така:
;(factorial-iter 5)
;(iter   1 1)
;(iter   1 2)
;(iter   2 3)
;(iter   6 4)
;(iter  24 5)
;(iter 120 6)
;120

; време: O(n)
; памет: O(1)

; Това е линеен итеративен процес заради липсата на отложени операции.
; (опашкова рекурсия)
; Scheme третира опашковата рекурсия като итеративен процес.


; Тази реализация поражда дървовиден рекурсивен процес
(define (fib n)
  (if (< n 2)
    n
    (+ (fib (- n 1))
       (fib (- n 2)))))

; време: O(2^n)

; Можем ли да го направим итеративно? (динамично програмиране)
; Ще намираме числата на фибоначи последователно и ще помним предходните две.
; Така няма да трябва да ги изчисляваме всеки път когато ни потрябват.
(define (fib-iter n)
  (define (iter n1 n2 index)
    (if (= index 0)
      n1
      (iter n2
            (+ n1 n2)
            (- index 1))))
  (iter 0 1 n))

;(time (fib 42))
;(time (fib-iter 42))
; time измерва колко време отнема на подадената функция да звърши


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; 1. Намира броя на цифрите на дадено естествено число n.
; Реализирайте я рекурсивно.
(define (count-digits n) void)

; 2. За дадени цяло число x и естествено число n връща x^n.
; Реализирайте я рекурсивно.
(define (powe x n) void)

; 3. За дадени числа a и b намира сумата на целите числа в интервала [a,b].
; Приемете че a < b.
; Реализирайте я рекурсивно.
(define (interval-sum a b) void)

; 4. Намира броя на цифрите на дадено цяло число n.
; Реализирайте я чрез линейна рекурсия (итерация).
(define (count-digits-i n) void)

; 5. За дадени числа a и b намира сумата на целите числа в интервала [a,b].
; Трябва да работи и за a > b.
; Реализирайте я чрез линейна рекурсия (итерация).
(define (interval-sum-i a b) void)

; 6. За дадено цяло число n връща число, чийто цифри са в обратен ред.
; Реализирайте го чрез линейна рекурсия (итерация).
(define (reverse-digits-i n) void)

; 7. За дадени цели числа x и n връща x^n.
; Реализирайте я чрез линейна рекурсия (итерация).
(define (pow-i x n) void)

; 8. За дадени цели числа x и n връща x^n. Но се възползва от свойството:
; ако n е четно, то x^n = (x^(n/2))^2. Реализирайте я чрез линейна рекурсия (итерация).
(define (fast-pow x n) void)
