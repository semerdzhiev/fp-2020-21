#lang racket

; Отложени операции

; delay от даден израз прави отложена операция
; или още - promise
(delay (+ 1 2)) ; #<promise>

; Как обаче да вземем резултата когато ни потрябва.
(define some-expression (delay (+ 1 2)))
; force взима дадена отложена операция (promise)
; и я оценява
(force some-expression) ; 3

; С помощта на тези 2 функции можем да си дефинираме потоци.
; Поток е списък, чиито елементи се оценяват отложено
; 1) '() е поток
; 2) (h. t) е поток точно когато:
;   - h е произволен елемент
;   - t е promise за поток.

(define empty-stream '())

(define-syntax cons-stream
  (syntax-rules () ((cons-stream h t)
                    (cons h (delay t)))))

; Ето и базовите функции за работа с потоци
; Когато ни трябва елемент от потока просто го взимаме (той е първият)
(define head car)

; Когато искаме да вземем опашката на потока, я оценяваме с force
(define (tail s)
  (force (cdr s)))

; Доста често ще искаме да взимаме елементи от поток.
; Нека видим как бихме имплементирали функцията take за потоци.
(define (stream-take n s)
  (if (or (zero? n) (null? s))
    '()
    (cons (head s)
          (stream-take (- n 1) (tail s)))))


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; Имплементирайте следните функции, генериращи безкрайни потоци

; Генерира безкраен поток от стойности v
; (repeat 1)
; (1 . #<promise>)
; (stream-take 5 (repeat 1))
; (1 1 1 1 1)
(define (repeat v) void)

; Генерира безкрайния поток x, f(x), f(f(x)), ...
(define (iterate f x)  void)

; Генерира безкраен поток от елементите на lst
; (cycle '(1 2 3)) би създало потока:
; 1, 2, 3, 1, 2, 3, 1 ...
(define (cycle lst) void)


; Граф ще представяме като списък на съседство
; Тоест списък от списъци от върхове.
; За връх v ще дефинираме списък (v v1 .. vn)
; Където v1 до v1 са върховете до които v има ребро
; За всеки връх ще пазим такъв списък.
; Списъка от тези списъци ще е нашият граф.
;
; 1 --> 2
; |     |
; v     v
; 3 --> 4 --> 5
;
; Бихме го записали:
'((1 2 3) ; 1 има ребро до 2 и 3
  (2 4)   ; 2 има ребро до 4
  (3 4)   ; 3 има ребро до 4
  (4 5)   ; 4 има ребро до 5
  (5))    ; 5 няма ребра до други върхове

'() ; празен граф
'((1 2 3) (2)) ; Невалидно защото твърдим че 1 има ребро до 3,
               ; но не сме включили списък за реброто 3

; Как да си създадем граф?
; Може да го конструираме само с върхове и без ребра
(define (make-graph vs)
  (map list vs))

; Още няколко функции за работа с графи:

; проверява дали графа g е празен.
(define empty-graph? null?)

; Списък от първите елементи на подсписъците на g
; са точно върховете на g.
; Но ние вече имаме функция която има същата дефиниция
(define vertices alist-keys)

; Добавяме списък от върха v,
; тоест той първоначално няма ребра до други върхове.
(define (add-vertex v g)
  (cons (list v) g))

; Дефинирайте следните функции за работа с графи
; Може да ползвате горните функции за асоциативни списъци
; Не забравяйте че списъците са двойки,
; тоест списък от списъци всъщност е асоциативен списък.
; (стига да няма празни списъци като елементи)
; !!! Но си вземете решенията от миналото упражнение

; връща списък от всички ребра на графа g.
(define (edges g) void)

; проверява дали има ребро от върха u до върха v в g.
(define (edge? u v g) void)

; връща списък от децата на върха v в g.
(define (children v g) void)

; връща списък от прилаганията на функцията f върху децата на v в g.
(define (map-children v f g) void)

; връща първото дете на v в g, което е вярно за предиката p.
(define (search-child v p g) void)

; премахване на върха v от графа g заедно с ребрата до него.
(define (remove-vertex v g) void)

; добавяне на ребро от u до v в g.
(define (add-edge u v g) void)

; премахване на ребро от u до v в g.
(define (remove-edge u v g) void)


; Имплементирайте следните функции за графи.

; връща степента на върха v в графа g.
(define (degree v g) void)

; проверява дали графа g е симетричен.
(define (symmetric? g) void)

; инвертира графа g. Тоест за всяко ребро (u,v) в g новият граф ще има реброто (v,u).
(define (invert g) void)

; проверява дали има път между върховете u и v в графа g.
(define (path? u v g) void)

; проверява дали графа g е ацикличен.
(define (acyclic? g) void)

