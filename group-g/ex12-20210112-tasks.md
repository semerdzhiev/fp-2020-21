# Упражнение 12 - Алгебрични типове данни

[код от упражнението](ex12-20210112-solutions.hs)

### Зад.0. (остатък от предишното упражнение)
Да се напише функция `specialSort`, която приема като параметър списък от списъци и го сортира относно най-често срещания елемент във всеки от вътрешните списъци. Ако има няколко най-често срещани елемента, да се избира най-големия от тях:
```haskell
specialSort ["moo", "bee", "eve", "abracadabra", "abcdefg", "mama", "z"]
  -> ["abracadabra", "bee", "eve", "abcdefg", "mama", "moo", "z"]
-- в случая най-често срещаните елементи са съответно 'a', 'e', 'e', 'g', 'm', 'o', 'z'
-- наредбата не е уникална - няма проблем с това, нямаме изисквания за стабилност
```

### Зад.1
Да се напише алгебричен тип данни `Parity`, който обозначава четността на дадено число. Да се реазлизират класовете `Eq`, `Ord`, `Show`, `Read`

_Бел.авт.:_ Eq е необходимо, за да използваме стойности от този тип в pattern matching - все пак той е синтактична захар за `if x == 5 then ... else ...`

### Зад.2.
Да се напише алгебричен тип данни `Maybe`, който или съдържа стойност от произволен тип, или не съдържа нищо. Да се реализират `Eq`, `Ord` за него.

### Зад.3.
Да се напишат следните функции за списъци (както и техните типови сигнатури). Целта е те да се възползват от `Maybe`, за да бъдат тотални функции и никога да на връщат `error`.
- safeHead
- safeTail
- safeUncons
- findIndex
- stripPrefix
- maybeToList
- mapMaybe

### Зад.4.
Да се напише алгебричен тип данни `NonEmpty`, който символизира непразен списък. За него се напишат аналози на някои от най-често използваните функции за обикновени списъци (head, tail, length, reverse, uncons)

_Упътване:_ добавете `infixr 5` за конструктора от глава и опашка на този списък

### Зад.5.
Да се напише функция `maxSumPath`, която приема за аргумент двоично дърво с числа във възлите и намира максималната сума на числата по някой път от корен до листо.

### Зад.6.
Да се напише функция `prune`, която по дадено двоично дърво `t` връща ново дърво `t'`, което представлява `t`, в което всички листа са премахнати.

### Зад.7.
Да се напише функция `bloom`, която по дадено двоично дърво `t` връща ново дърво `t'`, което представлява `t`, в което на всички листа са добавени по два наследника - нови листа. Стойността в тези нови листа да е същата, като в оригиналното листо, от което са излезли.

### Зад.8.
Да се имплементират стандартните ротации на двоични дървета:
![Tree rotations](https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png)

### Зад.9.
Да се напише функция `treeМap`, която `map`-ва дадена функция `f` на всички стойности в дадено дърво (тук не е задължително стойностите в дървото да са числа).

### Зад.10*.
Да се инстанцира класа от типове `Functor` за даден тип дърво с произволен брой наследници на всеки възел.

### Зад.11.
Да се дефинира тип `BST`, който да представлява двоично наредено дърво, съдържащо стойности от произволен тип във възлите си. Да се дефинират следните функции към него:
- `bstInsert :: Ord a => a -> BST a -> BST a` - добавяне на стойност в дървото
- `bstSearch :: Ord a => a -> BST a -> Bool`  - търсене на стойност в дървото
- `bstValues :: BST a -> [a]`                 - получаване на списък със всички стойности в дървото
- `bstSize :: BST a -> Int`                   - брой стойности, съдържани в дървото
- `bstSort :: Ord a => [a] -> [a]`            - сортиране, използвайки `BST` като междинна структура

### Зад.12.
Да се дефинира тип `Map`, който да представлява структурата от данни асоциативен списък, реализирана с двоично наредено дърво. Да се дефинират следните функции към нея:
- `mapInsert :: Ord k => k -> v -> Map k v -> Map k v` -- вмъкване на ключ със стойност в дървото. Ако стойност за този ключ съществува, нека тя да бъде заместена с новата.
- `mapSearch :: Ord k => k -> Map k v -> Maybe v`      -- търсене на стойност по ключ в дървото (обърнете внимание на върнатия тип)

### Зад.13*.
Да се дефинира тип `Direction`, който да символизира посока при търсене в двоично наредено дърво (ляво или дясно). Да се дефинира функция `bstPath :: Ord a => a -> BST a => ???`, която по даден елемент и двоично наредено дърво намира пътека (последователност от посоки) до елемента в дървото.

_Упътване:_ какъв трябва да е типът на резултата?

### Зад.14.
Да се дефинира тип `Expr`, който да представлява математически израз - функция на един аргумент. Освен този аргумент, този израз може да съдържа само числа (`Double`), или следните операции: събиране, изваждане, умножение, деление или степенуване* на два израза. Да се дефинират следните функции към него:
- `eval :: Expr -> Double -> Double` -- изчислява стойността на функцията по дадена стойност на аргумента ѝ
- `derive :: Expr -> Expr`           -- изчислява производната на дадена функция - тя очевидно също е функция, която искаме да можем отново да диференцираме или оценяваме точно.

\* за улеснение ще позволяваме само повдигане на израз на степен число, както и число на степен израз. Това значи, че няма да можем да представяме функции като x<sup>x</sup>, (1+2)<sup>x</sup> или x<sup>(3+5)</sup>

