# Упражнение 11 - Списъци, list comprehension

[код от упражнението](ex11-20210105-solutions.hs)

### Зад.0.
Припомнете си какво правят следните полезни функции за списъци. Очаква се от вас да можете да реализирате всяка една:
```haskell
map, filter, reverse, length, null, elem, take, drop, zip, zipWith, takeWhile, dropWhile
```
### Зад.1.
Използвайте `foldr` или `foldl`, за да напишете следните функции:
- minimum'/maximum'
- reverse'
- length'
- all'/any'
- append'
- replicate'
### Зад.2. Използвайте list comprehension, за да напишете следните функции:
- брой/сума на делителите на дадено число
- проверка дали дадено число е просто
- descartes - декартово произведение на два списъка
### Зад.3.
Да се генерира безкрайния списък `primes` от прости числа:
```haskell
take 5 primes -> [2,3,5,7,11]
```
### Зад.4*.
Да се генерира безкрайния списък от прости числа по метода на ситото на Ератостен.
### Зад.5.
Да се генерира безкраен списък, който съдържа всички наредени двойки от естествени числа.

_Упътване_: какъв резултат ще върне извикването на `elemIndex (2,3)` върху Вашия списък?
### Зад.6.
Да се генерира безкраен списък, който съдържа всички Питагорови тройки: наредени тройки от естествени числа, които могат да бъдат страни на правоъгълен триъгълник
### Зад.7.
Да се напише функция `compress`, която по списък от стойности връща списък от наредени двойки от вида (<стойност>, <брой последователни срещания>):
```haskell
compress [1,1,2,3,3,3,4,2,2,2,2,1] -> [(1,2),(2,1),(3,3),(4,1),(2,4),(1,1)]
compress "abba" -> [('a',1),('b',2),('a',1)]
```
### Зад.8.
Да се напише функция `maxRepeated`, която по списък от стойности връща дължината на най-дългия подсписък, съставен от еднакви стойности:
```haskell
maxRepeated [1,1,2,3,3,3,4,2,2,2,2,1,1] -> 4
```
### Зад.9.
Да се напише функция `makeSet`, която по даден списък връща всички негови уникални елементи (редът им няма значение):
```haskell
makeSet [1,1,2,3,3,3,4,2,2,2,1,1] -> [1,2,3,4]
makeSet "abba" -> "ab"
```
### Зад.10.
Да се напише функция `histogram`, която за всяка уникална стойност от даден списък връща списък от наредени двойки от вида (<стойност>, <общ брой срещания>):
```haskell
histogram [1,1,2,3,3,3,4,2,2,2,1,1] -> [(1,4),(2,4),(3,3),(4,1)]
```
### Зад.11.
Да се напише функция `maxDistance`, която получава списък от точки (наредени двойки `(Double, Double)`) и връща дължината на най-дългата отсечка между някои две от тях.
```haskell
maxDistance [(-1.1, 1), (1.8, 2), (3, 1), (-1, -2)] -> 5.0
```
### Зад.12*.
Да се напише функция `specialSort`, която приема като параметър списък от списъци и го сортира относно най-често срещания елемент във всеки от вътрешните списъци. Ако има няколко най-често срещани елемента, да се избира най-големия от тях:
```haskell
specialSort ["moo", "bee", "eve", "abracadabra", "abcdefg", "mama", "z"]
  -> ["abracadabra", "bee", "eve", "abcdefg", "mama", "moo", "z"]
-- в случая най-често срещаните елементи са съответно 'a', 'e', 'e', 'g', 'm', 'o', 'z'
-- наредбата не е уникална - няма проблем с това, нямаме изисквания за стабилност
```